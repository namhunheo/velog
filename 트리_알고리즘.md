## [코테] 트리 알고리즘

트리 알고리즘
트리란?
계층적 구조를 표현하는 자료구조

    A        ← 루트(Root)
   / \
  B   C      ← 자식(Child)
 / \
D   E        ← 리프(Leaf)
용어	의미
루트	트리의 시작 노드
부모 / 자식	연결된 상하 관계
리프	자식이 없는 노드
깊이(depth)	루트에서 해당 노드까지 거리
높이(height)	가장 깊은 리프까지의 거리
트리 핵심 성질 (재귀)
재귀적 구조
- 트리는 트리로 구성되어 있음
어떤 노드를 기준으로 보면 -> 그 아래는 또 하나의 트리
트리 탐색 알고리즘
DFS (깊이 우선 탐색)
전위 / 중위 / 후휘 순회
A
/ \
B C
/ \
D E
방식	방문 순서	용도
전위	A → B → D → E → C	구조 복사
중위	D → B → E → A → C	BST 정렬
후위	D → E → B → C → A	삭제, 계산
루트 기준 위치만 다름
def dfs(node):
    if not node: return
    dfs(node.left)
    dfs(node.right)
BFS (너비 우선 탐색)
레벨 단위 탐색
큐(Queue) 사용
from collections import deque

queue = deque([root])
while queue:
    node = queue.popleft()
    queue.append(node.left)
    queue.append(node.right)
최단 거리, 레벨 문제에 강함

이진 트리 vs 이진 탐색 트리(BST)
이진 트리

자식 ≤ 2개
정렬 규칙 ❌
이진 탐색 트리 (BST)

왼쪽 < 부모 < 오른쪽
✔ 중위 순회 → 오름차순 정렬

📌 시간 복잡도

평균: O(log N)
최악(편향): O(N)
자주 나오는 트리 문제 유형
높이 / 깊이 구하기
def height(node):
    if not node:
        return 0
    return max(height(node.left), height(node.right)) + 1
노드 개수 / 리프 개수
def count(node):
    if not node:
        return 0
    return count(node.left) + count(node.right) + 1
경로 문제 (최대합, 최소합)
def max_path(node):
    if not node:
        return 0
    return node.val + max(max_path(node.left), max_path(node.right))
트리 판단 문제
균형 트리
대칭 트리
동일한 트리
👉 왼쪽/오른쪽 결과를 비교
트리 알고리즘 사고 방식
3단계 사고법

함수의 의미 정의
기저 조건
좌우 서브트리 결과 조합
코테 문제풀이



문제 요약:
1번 노드를 루트로 했을 때, 각 노드들이 어느 부모에서 왔는지?

입력은 부모, 자식 정보가 없는 단순 연결 정보
문제 풀이

DFS와 BFS 중 BFS로.(큐라서 더 쉬울듯..?)
BFS로 생각해보면, 1번 노드부터 시작하고 연결된 노드를 하나씩 방문하고,
아직 방문 안한 노드를 보면 <그 노드의 부모 = 현재 노드>를 반복

중요사항
연결 정보 저장 (인접 리스트, 양방향 연결)
방문 체크 배열(무한루프 방지)
visited[node] = True
부모 배열 저장
parent[자식] = 부모
예제1을 인접리스트로 정리해보면,
1: [6, 4]
2: [4]
3: [6, 5]
4: [1, 2, 7]
5: [3]
6: [1, 3]
7: [4]
Step 1 – 루트 1 방문
1
/ \
6 4

부모 기록:
parent[6] = 1
parent[4] = 1
큐 상태: [6, 4]
Step 2 – 현재 6 방문
1
/ \
6 4
|
3

부모 기록:
parent[3] = 6
큐 상태: [4, 3]
Step 3 – 현재 4 방문
1
/ \
6 4
| / \
3 2 7

부모 기록:
parent[2] = 4
parent[7] = 4
큐 상태: [3, 2, 7]
Step 4 – 현재 3 방문
1
/ \
6 4
| / \
3 2 7
|
5

부모 기록:
parent[5] = 3
큐 상태: [2, 7, 5]
Step 5 ~ Step 7 – 남은 노드 방문
2 → 연결된 4 이미 방문 → 아무 일 없음
7 → 연결된 4 이미 방문 → 아무 일 없음
5 → 연결된 3 이미 방문 → 아무 일 없음

최종 트리 구조 (루트 1 기준)
1
/ \
6 4
| / \
3 2 7
|
5

부모 관계 (parent 배열)
2 → 4
3 → 6
4 → 1
5 → 3
6 → 1
7 → 4

큐와 visited를 이용해서 BFS로 탐색했음

전체 흐름 정리
1️⃣ 입력 N-1줄을 모두 읽는다
2️⃣ 인접 리스트를 만든다
3️⃣ 1번 노드부터 탐색 시작
4️⃣ 처음 방문한 노드의 이전 노드를 부모로 기록

코드로는

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 노드 개수

        // 1. 인접 리스트 생성
        ArrayList<Integer>[] tree = new ArrayList[n + 1]; // 1번부터 사용
        for (int i = 1; i <= n; i++) {
            tree[i] = new ArrayList<>();
        }

        // 2. 입력으로 연결 정보 저장 (양방향)
        for (int i = 0; i < n - 1; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            tree[a].add(b);
            tree[b].add(a);
        }

        // 3. 부모 배열과 방문 체크 배열
        int[] parent = new int[n + 1]; // parent[i] = i의 부모
        boolean[] visited = new boolean[n + 1];

        // 4. BFS 탐색
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1); // 루트 1번부터 시작
        visited[1] = true;

        while (!queue.isEmpty()) {
            int current = queue.poll(); // 현재 노드

            for (int next : tree[current]) { // 인접 노드 확인
                if (!visited[next]) { // 처음 방문한 노드면
                    visited[next] = true; // 방문 처리
                    parent[next] = current; // 부모 기록
                    queue.add(next); // 큐에 추가
                }
            }
        }

        // 5. 결과 출력 (2번 노드부터)
        for (int i = 2; i <= n; i++) {
            System.out.println(parent[i]);
        }
    }
}